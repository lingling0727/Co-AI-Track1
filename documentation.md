# 프로젝트 문서: `trial3` - ILP 및 대칭성 기반 선형 부호 분류기

본 문서는 유한체 $\mathbb{F}_q$ 상의 선형 부호 $[n, k]_q$ 중 특정 가중치 집합 $W$를 갖는 부호를 분류(Classification)하거나 존재성을 판별하는 `trial3` 프로젝트의 아키텍처, 핵심 알고리즘, 최적화 기법을 상세히 설명합니다.

이 프로젝트의 목표는 전통적인 격자점 열거(Lattice Point Enumeration) 방식의 계산 복잡도를 해결하기 위해, 현대적인 정수 선형 계획법(Integer Linear Programming, ILP)과 기하학적 대칭성(Geometric Symmetry)을 결합한 고성능 탐색 프레임워크를 구현하는 것입니다.

---

## 1. 연구 배경 및 문제 정의

### 1.1. 선형 부호 분류 문제
선형 부호 분류는 주어진 파라미터(길이 $n$, 차원 $k$, 유한체 크기 $q$)와 특정 조건을 만족하는 모든 부호를 찾는 문제입니다. 특히, 우리는 부호어들의 무게(0이 아닌 성분의 개수)가 특정 집합 $W$에 포함되는 부호를 찾는 데 집중합니다.

### 1.2. 기하학적 재해석: 격자점 열거 문제
이 문제는 사영 기하학(Projective Geometry) $PG(k-1, q)$의 점(Point)들을 선택하는 조합 문제로 재해석될 수 있습니다.

- **부호와 생성 행렬**: $k \times n$ 생성 행렬 $G$의 각 열(column)은 $k$차원 벡터 공간 $\mathbb{F}_q^k$의 한 점으로 볼 수 있습니다.
- **사영 공간의 점**: 스칼라 배 관계에 있는 벡터들은 같은 1차원 부분 공간을 나타내므로, $PG(k-1, q)$의 점들로 정규화하여 다룹니다. $PG(k-1, q)$는 $\frac{q^k-1}{q-1}$개의 점을 가집니다.
- **부호어와 초평면**: 생성 행렬 $G$의 행(row)들의 선형 결합으로 만들어지는 각 부호어(codeword)는 $PG(k-1, q)$의 초평면(hyperplane)에 대응됩니다.
- **가중치와 점의 개수**: 부호어 $c$의 가중치 $w(c)$는 $n - |\{P \in C | P \cdot H_c = 0\}|$ 와 같습니다. 즉, 부호의 가중치 집합 $W$를 제한하는 것은, 각 초평면 $H$ 위에 놓이는 점들의 개수(중복 포함)를 $n-w$ ($w \in W$)로 제한하는 것과 같습니다.

결론적으로, 부호 분류 문제는 **"각 사영 점 $P_i$를 몇 개씩($x_i$개) 선택하여 총 $n$개를 만들 것인가?"** 라는 디오판토스 방정식(Diophantine Equation)의 정수 해 $x_i$를 찾는 문제가 됩니다. 이는 본질적으로 **격자점 열거(Lattice Point Enumeration)** 문제입니다.

### 1.3. `trial3`의 접근 방식
전통적인 격자점 열거 알고리즘(예: 순수 백트래킹)은 파라미터가 조금만 커져도 탐색 공간이 폭발하여 비현실적입니다. `trial3`는 이 문제를 해결하기 위해 다음과 같은 현대적인 접근법을 채택합니다.

1.  **ILP로의 완전한 전환**: 문제를 직접 탐색하는 대신, 모든 제약 조건을 담은 정수 선형 계획법(ILP) 모델로 정교하게 변환합니다.
2.  **고성능 솔버 활용**: 직접 구현한 탐색기 대신, 세계 최고 수준의 상용 솔버인 **Gurobi**에 ILP 모델을 전달하여 해를 찾습니다. Gurobi는 지난 수십 년간 발전된 최첨단 알고리즘(Presolve, Cutting Planes, Heuristics 등)을 내장하고 있어 압도적인 성능을 보입니다.
3.  **사전/사후 가지치기**: 단순히 ILP로 변환하는 것을 넘어, 문제의 수학적/기하학적 특성을 이용해 탐색 공간을 사전에 대폭 줄이는 **가지치기(Pruning)** 기법들을 여러 단계에 걸쳐 적용합니다.

---

## 2. 전체 진행 프로세스 (The `trial3` Workflow)

`trial3`의 핵심은 여러 단계의 필터를 거쳐 점진적으로 탐색 공간을 줄여나가는 파이프라인 구조입니다.

!Workflow <!-- 다이어그램 이미지 URL을 넣으면 좋습니다 -->

### **Phase -1: 기하학적 구조 생성 (`geometry.py`)**
탐색에 필요한 모든 기하학적 객체를 미리 생성합니다.

1.  **사영 점 및 초평면 생성**: `generate_projective_points(k, q)`를 통해 $PG(k-1, q)$의 모든 점을 생성합니다. 초평면은 점과 쌍대(dual) 관계이므로 동일한 함수로 생성됩니다.
2.  **결합 행렬 생성**: `get_incidence_matrix(points, hyperplanes, q)`를 통해 어떤 점이 어떤 초평면에 포함되는지를 나타내는 $M \times N$ 행렬을 생성합니다. ($M$: 초평면 수, $N$: 점의 수)
3.  **대칭 그룹 생성**: `generate_gl_generators(k, q)` 및 `get_orbits(points, matrices, q)`를 통해 $PG(k-1, q)$에 작용하는 일반 선형 그룹 $GL(k, q)$의 생성원(generators)과 그로 인한 점들의 **궤도(Orbits)**를 계산합니다. 이는 Phase 1.5의 핵심 최적화를 위해 필수적입니다.

### **Phase 0: 사전 가지치기 (Pre-Pruning / Feasibility Checks)**
본격적인 탐색에 들어가기 전, 해가 존재할 수 없는 파라미터 조합을 매우 저렴한 비용으로 걸러냅니다.

#### **Phase 0.1: 이론적 경계 검사 (`_phase_0_5_checks`)**
부호 이론의 여러 수학적 정리를 이용해 해의 존재 조건을 확인합니다.

- **그리스머 경계 (Griesmer Bound)**: 부호의 최소 거리 $d$가 주어졌을 때, 길이가 만족해야 할 최소 조건 $n \ge \sum_{i=0}^{k-1} \lceil d / q^i \rceil$을 검사합니다. 만약 $n$이 이보다 작으면 해는 존재하지 않습니다.
- **플레스 파워 모멘트 (Pless Power Moments)**: 부호의 가중치 분포 $\{A_w\}$가 만족해야 하는 선형 방정식들을 이용합니다. `_check_pless_moments` (trial2 참조)에서는 이 방정식들의 정수 해가 존재하는지를 작은 ILP 문제로 풀어 확인합니다. 해가 없으면 해당 가중치 집합 $W$는 불가능합니다.

#### **Phase 0.2: ILP 기반 빠른 불가능성 검사 (`_check_phase0_gurobi`)**
실제 ILP 모델의 제약 조건을 완화한(relaxed) 버전을 만들어 Gurobi로 빠르게 풀어봅니다.

- **원본 제약**: 각 초평면 $H$ 위의 점 개수 $S_H$는 $\{n-w | w \in W\}$ 집합 안의 값 중 하나여야 합니다. (e.g., $S_H=10$ 또는 $S_H=12$)
- **완화된 제약**: $S_H$는 단순히 최솟값과 최댓값 사이에 있으면 됩니다. (e.g., $10 \le S_H \le 12$)

만약 이처럼 **더 넓은 조건을 가진 완화된 문제조차 해가 없다면, 더 엄격한 원본 문제는 당연히 해가 없습니다.** 이 검사를 통과하지 못하면 즉시 탐색을 중단하여 막대한 시간을 절약합니다.

### **Phase 1: 대칭성을 이용한 최적화 탐색 (Symmetry-Aware Optimized Search)**
사전 가지치기를 통과한 문제에 대해, Gurobi를 이용한 본격적인 해 탐색을 시작합니다.

#### **Phase 1.5: 궤도 분기 (Orbital Branching)**
이것이 `trial3`의 가장 강력한 최적화 기법 중 하나입니다.

- **문제점**: 기하학적으로 동형(isomorphic)인, 즉 구조적으로 동일한 해들이 탐색 과정에서 수없이 중복 발견됩니다. 예를 들어, 점 $\{P_1, P_2, P_3\}$을 선택한 해와, 여기에 $GL(k,q)$의 변환 $A$를 적용한 $\{A(P_1), A(P_2), A(P_3)\}$를 선택한 해는 같은 부호로 취급해야 합니다.
- **해결책**: $GL(k,q)$의 작용에 의해 점들은 여러 개의 **궤도(Orbit)**로 분할됩니다. 같은 궤도에 속한 점들은 기하학적으로 동등한 위치에 있습니다. 따라서 **탐색을 시작할 때(첫 번째 점을 선택할 때), 모든 점을 시도할 필요 없이 각 궤도의 대표점(representative) 하나씩만 시도해보면 충분합니다.**
- **구현**: `ilp_model.py`의 `build_and_solve` 함수는 `get_orbits`로 얻은 대표점 `rep_indices` 리스트를 순회합니다. 각 반복마다 Gurobi에 다음과 같은 제약을 추가하여 독립적인 하위 문제(sub-problem)를 생성하고 풀어냅니다.
  - `x[r_i] >= 1`: "이번 탐색은 $i$번째 궤도의 대표점 $r_i$를 반드시 하나 이상 포함하는 해만 찾는다."
  - `x[r_j] == 0` for $j < i$: "이전 궤도들의 대표점들은 포함하지 않는다." (중복 방지)

이 기법은 탐색 트리의 최상단 너비를 (전체 점의 개수)에서 (궤도의 개수)로 획기적으로 줄여주며, 이는 특히 $k, q$가 클수록 효과가 극대화됩니다.

#### **Phase 1.6: Gurobi ILP 모델링 및 풀이 (`_solve_gurobi`)**
각 하위 문제에 대해 다음과 같이 정교하게 구성된 ILP 모델을 Gurobi에 전달합니다.

- **결정 변수 (Decision Variables)**
  - $x_P \in \mathbb{Z}_{\ge 0}$: 사영 공간의 각 점 $P$가 생성 행렬의 열로 선택된 횟수(multiplicity).

- **제약 조건 (Constraints)**
  1.  **길이 제약 (Length Constraint)**: 모든 점의 선택 횟수 합은 부호의 길이 $n$과 같아야 합니다.
      $$ \sum_{P \in PG(k-1, q)} x_P = n $$
  2.  **가중치 제약 (Weight Constraint)**: 모든 초평면 $H$에 대해, $H$에 포함된 점들의 선택 횟수 합($S_H$)은 허용된 교차 크기 집합($\{n-w | w \in W\}$)에 속해야 합니다.
      $$ S_H = \sum_{P \in H} x_P \in \{n-w \mid w \in W\} $$
      - **모델링 최적화**: 이 "OR" 조건은 ILP에서 다루기 까다롭습니다.
        - **(고정 가중치)** 만약 $|W|=1$이면, 단순 등식 `expr == k`로 모델링하여 매우 빠르게 풀 수 있습니다.
        - **(가변 가중치)** $|W|>1$이면, 이진(binary) 보조 변수 $z_k$를 도입하여 `expr == sum(k * z_k)` 와 `sum(z_k) == 1` 형태로 변환합니다. 이는 Gurobi가 효율적으로 처리하는 **SOS1(Special Ordered Set)** 또는 **Indicator Constraint**와 동일한 효과를 냅니다.
  3.  **궤도 분기 제약 (Orbital Branching Constraints)**: Phase 1.5에서 설명한 `forced_index`와 `forbidden_indices`에 대한 제약이 여기에 추가됩니다.
  4.  **Gurobi 파라미터 튜닝**: `Symmetry=2` (공격적인 대칭성 감지), `Presolve=2` (공격적인 사전 해결) 등 Gurobi 내부의 최적화 옵션을 활성화하여 성능을 극대화합니다.

- **해 탐색 (Solution Search)**
  - `PoolSearchMode=2`와 `PoolSolutions=2000000` 옵션을 통해, Gurobi가 최적해 하나만 찾고 멈추는 것이 아니라, 가능한 모든 유효한 해(feasible solutions)를 찾도록 지시합니다.

### **Phase 2: 해 검증 및 필터링 (`checker.py`)**
Gurobi가 찾은 여러 해들 중에서 중복되거나 구조적으로 동일한(isomorphic) 해들을 최종적으로 걸러냅니다.

1.  **가중치 분포 계산 (`get_weight_distribution`)**: 각 해(solution)에 대해 실제 부호의 가중치 분포(e.g., "가중치 28짜리 100개, 가중치 32짜리 50개")를 계산합니다. 이 분포는 강력한 동형 불변량(isomorphism invariant)이므로, 분포가 다른 해들은 절대 동형일 수 없습니다. 이를 이용해 1차로 해들을 그룹화합니다.
2.  **엄밀한 동형성 검사 (`are_codes_isomorphic`)**: 같은 가중치 분포 그룹 내의 후보 해들에 대해서만 최종 검사를 수행합니다. 한 해($sol_1$)의 점 집합에 $GL(k,q)$의 변환 행렬 $A$를 적용했을 때, 다른 해($sol_2$)의 점 집합과 정확히 일치하는 $A$가 존재하는지 확인합니다. 존재하면 두 해는 동형이므로 하나만 남깁니다.

---

## 3. 주요 최적화 기법 요약 및 효과

`trial3`에 적용된 핵심 최적화 기법들과 각각이 효과적인 상황은 다음과 같습니다.

| 기법 (Method) | 설명 | 가장 효과적인 문제 유형 |
| :--- | :--- | :--- |
| **1. 이론적 경계 검사**<br>(Theoretical Bounds) | 수학적 정리(Griesmer, Pless 등)를 이용해 탐색 시작 전 해의 존재 가능성을 빠르게 판단합니다. | 파라미터($n,k,d,q$)가 이론적 한계에 가깝거나 위반하는 경우. 탐색 자체를 원천 차단하므로 **가장 비용 효율적인** 기법입니다. |
| **2. ILP 불가능성 검사**<br>(ILP Feasibility Check) | 제약 조건을 완화한 간단한 ILP 모델을 먼저 풀어, 원본 문제의 불가능성(infeasibility)을 조기에 감지합니다. | 제약 조건들 간의 모순이 비교적 명백하여, 선형 완화(LP relaxation)만으로도 해가 없음이 드러나는 문제에 효과적입니다. |
| **3. 궤도 분기**<br>(Orbital Branching) | 기하학적 대칭성을 이용해 동형인 해를 만드는 중복 탐색 경로를 원천적으로 제거합니다. 탐색 공간을 독립적인 하위 문제로 분할합니다. | **`trial3`의 핵심.** $q$와 $k$가 커서 대칭성이 높은 문제에서 효과가 극대화됩니다. 점의 개수 대비 궤도의 수가 훨씬 적을수록 탐색 공간 감소율이 기하급수적으로 커집니다. |
| **4. 고성능 솔버 위임**<br>(Delegation to Gurobi) | 직접 구현한 탐색 로직 대신, 상용 ILP 솔버의 최첨단 알고리즘에 문제 풀이를 맡깁니다. | 거의 모든 종류의 문제, 특히 순수 백트래킹으로는 수 시간/수일이 걸리는 **크고 복잡한 문제**에서 압도적인 성능 차이를 보입니다. |
| **5. 최적화된 ILP 모델링**<br>(Optimized ILP Modeling) | 문제 특성에 맞춰 ILP 제약식을 구성합니다. (e.g., 고정 가중치 문제에 단순 등식 사용) | **고정 가중치(fixed-weight)**를 갖는 부호 탐색 문제에서, 복잡한 'OR' 조건이 사라지므로 ILP 솔버의 사전 해결(Presolve) 단계에서 엄청난 성능 향상을 보입니다. |

---

## 4. 코드 구조

- **`main.py`**:
  - 프로그램의 진입점(entry point).
  - 사용자로부터 파라미터($n, k, q, W$)를 입력받습니다.
  - 전체 워크플로우(Geometry 생성 -> ILP 모델 생성 및 해결 -> 결과 저장)를 총괄합니다.

- **`ilp_model.py`**:
  - `trial3`의 **심장(Heart)**. `CodeExtender` 클래스가 구현되어 있습니다.
  - Phase 0, 1.5, 1.6의 모든 로직, 즉 Gurobi 모델을 생성, 최적화, 실행하는 코드가 포함됩니다.

- **`geometry.py`**:
  - **기반(Foundation)**. 유한체 연산, 사영 공간의 점/초평면 생성, 결합 행렬 계산, 대칭성 그룹 및 궤도 계산 등 모든 기하학적 연산을 담당합니다.

- **`checker.py`**:
  - **후처리(Post-processing)**. Gurobi가 찾은 해들을 검증하고, 최종적으로 동형이 아닌 유일한 해들만 필터링하는 역할을 합니다.

- **`compare_performance.py`**:
  - `trial3`의 접근법과 이전 버전(e.g., `trial2`의 Custom Backtracking) 또는 다른 논문의 Baseline 방법론과 성능을 정량적으로 비교하고 결과를 CSV 파일로 저장하는 스크립트입니다.

---

## 5. 결론

`trial3`는 선형 부호 분류라는 복잡한 조합 최적화 문제를, 단순한 백트래킹 방식에서 벗어나 **정수 선형 계획법(ILP)** 이라는 강력한 프레임워크 위에서 해결하는 현대적인 접근법을 제시합니다.

특히, 문제 고유의 **기하학적 대칭성을 활용한 궤도 분기(Orbital Branching)** 기법은 기존 ILP 모델링 연구에서 한 걸음 더 나아가, 탐색 공간 자체를 근본적으로 줄이는 핵심적인 기여라고 할 수 있습니다. 여러 단계의 이론적/수학적 가지치기 기법과 결합된 이 파이프라인은, 기존 방법으로는 접근하기 어려웠던 큰 파라미터의 문제에 대한 해를 효율적으로 탐색할 수 있는 가능성을 엽니다.

이 문서는 `trial3`의 구현 내용과 그 배경에 있는 아이디어를 종합적으로 정리한 것으로, 향후 연구 방향 설정, 논문 작성, 코드 유지보수에 중요한 기준으로 활용될 수 있을 것입니다.

