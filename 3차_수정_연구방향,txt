##구현 요약 

- **방법 1, 2는 필수 코어 (branch-and-bound 안쪽)**
- **방법 3은 바깥 껍질 (탐색 공간 자체를 줄이는 프레임워크)**

즉,

> 3 ⟶ (대칭 제거된 탐색 틀)
> 
> 
> ↳ **2 ⟶ (노드 생성 자체를 줄이는 prune)**
> 
> ↳ **1 ⟶ (노드에서 제약 검사 비용을 줄이는 체크 방식)**
> 

---

## 전체 알고리즘 파이프라인 (단계별)

### 🔹 Stage 0. 문제 모델 (변하지 않는 부분)

- 변수: (x_P) (점의 multiplicity)
- 제약:
    - (\sum_P x_P = n)
    - 모든 hyperplane (H): (\sum_{P\in H} x_P \le n-d)
- 목표: feasible lattice point 존재/열거

👉 **이건 Kurz류랑 완전히 동일**

---

## 🔹 Stage 1. 탐색 “틀”을 줄인다 → **방법 3**

### (Orbit-representative / canonical augmentation)

**언제?**

👉 *branching 하기 “전”*, 또는 *branch variable 선택 단계*

**무엇을?**

- 아직 값이 안 정해진 점들 중
- 현재 partial assignment의 automorphism group (G) 계산
- (G)-orbit마다 **대표 점 1개만 branching**

**효과**

- 같은 해를 대칭으로 여러 번 만드는 걸 **원천 차단**
- 분기 수 자체 감소 (지수적으로 큼)

**중요**

- ❌ 하드 bound랑 관계 없음
- ❌ 제약 검사 최적화 아님
- ✅ “탐색 트리 구조”를 줄이는 역할

> 그래서 방법 3은 가장 바깥 레벨에 둔다.
> 

---

## 🔹 Stage 2. 노드를 아예 만들지 말자 → **방법 2 (RCUB pruning)**

### (Remaining Capacity Upper Bound)

**언제?**

👉 *새 노드를 내려가기 직전*,

즉 “branch 값 하나 정하고 DFS 들어가기 전에”

**무엇을 검사?**

현재 partial assignment에서:

$$
\sum_{P\in U}\min!\Bigl(n_{\text{rem}},\min_{H\ni P} ((n-d)s_H)\Bigr);\ge;n_{\text{rem}}
$$

**깨지면?**

- ❌ 이 아래는 **절대 해 없음**
- → **branch 자체를 안 만듦**

**효과**

- 특히 **비존재 증명**에서 폭발적으로 먹힘
- 노드 수 자체를 줄이는 *가장 강한 가속기*

**중요**

- ✔ 하드 hyperplane bound만 사용
- ✔ 정답성 100% 유지
- ✔ ILP에서도 그대로 쓸 수 있는 pruning

> 그래서 방법 2는 branch 생성 단계에 둔다.
> 

---

## 🔹 Stage 3. 이미 들어온 노드에서 싸게 검사 → **방법 1**

### (Watched-Hyperplane propagation)

**언제?**

👉 *값 하나 대입한 직후*, 노드 안에서

**무엇을?**

- (x_P)가 변했으면

$$
(P \in H) 
$$

**왜 되는가?**

인 hyperplane만 검사

$$
(x_P \ge 0)
$$

- hyperplane 합은 **단조 증가**
- 위반은 “갱신된 hyperplane”에서만 새로 생김

**효과**

- hyperplane 검사 비용 3×~20× 절감
- 노드 수는 안 줄지만, **노드 하나당 비용 감소**

> 그래서 방법 1은 가장 안쪽에 둔다.
> 

---

## 그림으로 요약

```
[Canonical / Orbit branching]   ← 방법 3
        ↓
 choose representative point
        ↓
 try value v
        ↓
 [RCUB pruning check]           ← 방법 2
        ↓ (통과)
 assign x_P = v
        ↓
 [Watched hyperplane checks]    ← 방법 1
        ↓
 DFS recurse

```

---

## 그래서 “다 넣어야 하냐?”에 대한 진짜 답

### 최소 구성 (현대 표준 + 개선)

- ✔ 방법 1 + 방법 2
    
    👉 **이것만 해도 논문에 충분히 새롭고 강함**
    

### 풀스택 (최상급 계산)

- ✔ 방법 1 + 방법 2 + 방법 3
    
    👉 **대형 분류 / 극한 파라미터**에서 필수
    

### 추천 순서 (구현 난이도 대비 효과)

1. **방법 2 (RCUB)** ← 가장 큰 성능 점프
2. **방법 1 (Watched)** ← 구현 쉽고 즉각적 효과
3. **방법 3 (Orbit)** ← 어렵지만 최종 병목 해결